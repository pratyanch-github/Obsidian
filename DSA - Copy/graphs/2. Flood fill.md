New things i learnt 

>  1. Actually flood fill is not simple dfs only. As per usaco guide flood fill is for Finding connected components in a graph represented by a grid.
>  2. we have two types of implementations i.e dfs and bfs with stack for floop fill.
>  

> [!NOTE]
> In case of grids we have to find connected components based on some conditions, example we say those cells connected component which has same value. 
> 
> ![[{82ED8371-DD0E-4BEA-9051-AD63D33240A6}.png]]



Below is the code for inputting grid graph.

```cpp
#include <iostream>
using namespace std;

// Constants
const int MAX_N = 1000; // Maximum grid dimensions

// Global grid and dimensions
int grid[MAX_N][MAX_N];
int row_num, col_num;

int main() {
    // Input the grid dimensions
    cin >> row_num >> col_num;

    // Input the grid values
    for (int r = 0; r < row_num; r++) {
        for (int c = 0; c < col_num; c++) {
            cin >> grid[r][c];
        }
    }

    return 0; // Program completed successfully
}

```


Dfs floodfill- 

```cpp
#include <iostream>
#include <stack>
#include <string>

using namespace std;

const int MAX_N = 2500;
const int R_CHANGE[]{0, 1, 0, -1};
const int C_CHANGE[]{1, 0, -1, 0};

int row_num;
int col_num;
string building[MAX_N];
bool visited[MAX_N][MAX_N];

void floodfill(int r, int c) {
	// Note: you can also use a queue and pop from the front for a BFS-based
	// approach
	stack<pair<int, int>> frontier;
	frontier.push({r, c});
	while (!frontier.empty()) {
		r = frontier.top().first;
		c = frontier.top().second;
		frontier.pop();

		if (r < 0 || r >= row_num || c < 0 || c >= col_num || building[r][c] == '#' ||
		    visited[r][c])
			continue;

		visited[r][c] = true;
		for (int i = 0; i < 4; i++) {
			frontier.push({r + R_CHANGE[i], c + C_CHANGE[i]});
		}
	}
}

int main() {
	cin >> row_num >> col_num;
	for (int i = 0; i < row_num; i++) { cin >> building[i]; }

	int room_num = 0;
	for (int i = 0; i < row_num; i++) {
		for (int j = 0; j < col_num; j++) {
			if (building[i][j] == '.' && !visited[i][j]) {
				floodfill(i, j);
				room_num++;
			}
		}
	}
	cout << room_num << endl;
}
```

	BFS floodfill - 

```cpp
#include <iostream>
#include <stack>
#include <string>

using namespace std;

const int MAX_N = 2500;
const int R_CHANGE[]{0, 1, 0, -1};
const int C_CHANGE[]{1, 0, -1, 0};

int row_num;
int col_num;
string building[MAX_N];
bool visited[MAX_N][MAX_N];

void floodfill(int r, int c) {
	// Note: you can also use a queue and pop from the front for a BFS-based
	// approach
	stack<pair<int, int>> frontier;
	frontier.push({r, c});
	while (!frontier.empty()) {
		r = frontier.top().first;
		c = frontier.top().second;
		frontier.pop();

		if (r < 0 || r >= row_num || c < 0 || c >= col_num || building[r][c] == '#' ||
		    visited[r][c])
			continue;

		visited[r][c] = true;
		for (int i = 0; i < 4; i++) {
			frontier.push({r + R_CHANGE[i], c + C_CHANGE[i]});
		}
	}
}

int main() {
	cin >> row_num >> col_num;
	for (int i = 0; i < row_num; i++) { cin >> building[i]; }

	int room_num = 0;
	for (int i = 0; i < row_num; i++) {
		for (int j = 0; j < col_num; j++) {
			if (building[i][j] == '.' && !visited[i][j]) {
				floodfill(i, j);
				room_num++;
			}
		}
	}
	cout << room_num << endl;
}

```