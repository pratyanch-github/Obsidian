# Spring Boot Fundamentals: A Beginner's Guide

## Introduction: What is Spring Boot?

Spring Boot is a framework that makes developing Java applications much easier. Think of it as a helper that takes care of all the complex setup and configuration, so you can focus on writing code that solves your business problems.

**Why Spring Boot exists:**
- Traditional Java applications required lots of configuration
- Spring Framework improved things but still needed significant setup
- Spring Boot simplifies everything with "convention over configuration"

> **Quick Context:** Spring Boot builds on top of the Spring Framework, which itself was created to simplify Java enterprise development. Before Spring, developers used Java Servlets directly (Java classes that handle web requests) which required a lot of manual configuration.

## Part 1: Getting Started with Spring Boot

### 1.1 Creating Your First Spring Boot Application

The easiest way to start is with Spring Initializr (https://start.spring.io):

1. Select **Maven** or **Gradle** (build tools that manage dependencies)
2. Choose **Java** as your language
3. Select the latest stable Spring Boot version
4. Add dependencies: Start with "Spring Web" for web applications
5. Click "Generate" to download your project template

Open this project in your IDE (like IntelliJ, Eclipse, or VS Code).

### 1.2 Understanding Project Structure

```
my-first-project/
├── src/
│   ├── main/
│   │   ├── java/       # Your Java code goes here
│   │   └── resources/  # Configuration files go here
│   └── test/           # Test code goes here
└── pom.xml             # Project configuration (or build.gradle)
```

The main application class looks like this:

```java
@SpringBootApplication
public class MyFirstProjectApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyFirstProjectApplication.class, args);
    }
}
```

**The magic annotation `@SpringBootApplication` does three things:**
1. `@Configuration`: Marks the class as a source of bean definitions
2. `@ComponentScan`: Tells Spring to look for other components in the current package and below
3. `@EnableAutoConfiguration`: Tells Spring Boot to configure your application automatically based on dependencies

### 1.3 Running Your Application

Just run the main method in your application class. Spring Boot includes an embedded web server (usually Tomcat), so you don't need to deploy to a separate server.

When it starts, you'll see logs in the console, and your application will be available at `http://localhost:8080`.

## Part 2: Key Spring Boot Concepts

### 2.1 Dependency Injection (The Heart of Spring)

Dependency Injection (DI) means your classes don't create the objects they depend on—they're provided ("injected") by Spring.

**Why it matters:** Your code becomes more modular, testable, and maintainable.

**Example:**
```java
// Without dependency injection
class OrderService {
    private PaymentService paymentService = new PaymentServiceImpl();
    // Now you're stuck with this implementation!
}

// With dependency injection
@Service
class OrderService {
    private final PaymentService paymentService;
    
    // Spring automatically provides the paymentService object
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}
```

### 2.2 Spring Beans and Components

**Spring Beans** are objects managed by the Spring container. You don't create them with `new`—Spring does that for you.

The most common ways to define beans:

1. **Component scanning**: Using annotations like:
   - `@Component`: Generic component
   - `@Service`: Business logic component 
   - `@Repository`: Data access component
   - `@Controller`/`@RestController`: Web component

2. **Java Configuration**: Using `@Bean` methods:
```java
@Configuration
public class AppConfig {
    @Bean
    public PaymentService paymentService() {
        return new PaymentServiceImpl();
    }
}
```

### 2.3 Configuration Properties

Spring Boot lets you easily configure your application using `application.properties` or `application.yml`:

```properties
# application.properties
server.port=9090
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
```

You can access these properties in your code:

```java
@Value("${server.port}")
private int serverPort;

// Or for grouped properties:
@ConfigurationProperties(prefix = "mail")
public class MailProperties {
    private String host;
    private int port;
    // getters and setters
}
```

## Part 3: Building Web Applications with Spring Boot

### 3.1 Creating REST APIs

REST APIs are built using `@RestController`:

```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    @GetMapping
    public List<User> getAllUsers() {
        // Return all users
    }
    
    @GetMapping("/{id}")
    public User getUserById(@PathVariable Long id) {
        // Return user with the given id
    }
    
    @PostMapping
    public User createUser(@RequestBody User user) {
        // Create a new user
    }
    
    @PutMapping("/{id}")
    public User updateUser(@PathVariable Long id, @RequestBody User user) {
        // Update existing user
    }
    
    @DeleteMapping("/{id}")
    public void deleteUser(@PathVariable Long id) {
        // Delete user
    }
}
```

> **Servlet Context:** Behind the scenes, Spring Boot uses the Servlet API, but abstracts away the complexity. In traditional Servlet programming, you'd have to configure a servlet container, map URLs to servlets, and handle requests/responses directly. Spring Boot does all of that for you—`@RestController` methods automatically get mapped to servlet endpoints.

### 3.2 Request Parameters and Path Variables

You can get data from the request URL in several ways:

```java
// From path: /users/123
@GetMapping("/users/{id}")
public User getUser(@PathVariable("id") Long userId) { ... }

// From query string: /users?active=true
@GetMapping("/users")
public List<User> getActiveUsers(@RequestParam(defaultValue = "false") boolean active) { ... }

// From request body (for POST/PUT):
@PostMapping("/users")
public User createUser(@RequestBody User user) { ... }
```

### 3.3 Service Layer

Controllers should be thin and delegate to services:

```java
@Service
public class UserService {
    private final UserRepository userRepository;
    
    // Constructor injection
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
    
    // Other methods
}

@RestController
@RequestMapping("/api/users")
public class UserController {
    private final UserService userService;
    
    // Constructor injection
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @GetMapping
    public List<User> getAllUsers() {
        return userService.getAllUsers();
    }
    
    // Other endpoints
}
```

## Part 4: Data Access with Spring Boot

### 4.1 Spring Data JPA

Spring Data JPA makes database access simple:

1. Define an entity (a class that maps to a database table):

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    
    // Getters and setters
}
```

2. Create a repository interface:

```java
public interface UserRepository extends JpaRepository<User, Long> {
    // That's it! You get CRUD operations for free
    
    // Custom query methods
    List<User> findByEmail(String email);
    List<User> findByNameContaining(String namePart);
}
```

3. Use the repository in your service:

```java
@Service
public class UserService {
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User createUser(User user) {
        return userRepository.save(user);
    }
    
    // More methods
}
```

### 4.2 Database Configuration

Configure your database in `application.properties`:

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password

# Hibernate properties
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

## Part 5: Error Handling and Validation

### 5.1 Exception Handling

Handle exceptions in a centralized way:

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse("NOT_FOUND", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse("INTERNAL_ERROR", "An unexpected error occurred");
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

### 5.2 Validation

Validate input data using Bean Validation:

```java
public class UserRequest {
    @NotBlank(message = "Name is required")
    private String name;
    
    @Email(message = "Email should be valid")
    @NotBlank(message = "Email is required")
    private String email;
    
    // Getters and setters
}

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping
    public User createUser(@Valid @RequestBody UserRequest userRequest) {
        // The @Valid annotation triggers validation
        // If validation fails, Spring Boot returns a 400 Bad Request
    }
}
```

## Part 6: Testing Spring Boot Applications

### 6.1 Unit Testing Services

```java
@ExtendWith(MockitoExtension.class)
public class UserServiceTest {

    @Mock
    private UserRepository userRepository;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    void shouldReturnUserWhenUserExists() {
        // Arrange
        User expectedUser = new User();
        expectedUser.setId(1L);
        when(userRepository.findById(1L)).thenReturn(Optional.of(expectedUser));
        
        // Act
        User actualUser = userService.getUserById(1L);
        
        // Assert
        assertEquals(expectedUser, actualUser);
    }
}
```

### 6.2 Integration Testing

```java
@SpringBootTest
public class UserControllerIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    void shouldCreateUser() {
        // Create user request
        UserRequest request = new UserRequest();
        request.setName("John");
        request.setEmail("john@example.com");
        
        // Send POST request
        ResponseEntity<User> response = restTemplate.postForEntity(
            "/api/users", request, User.class);
        
        // Verify
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody().getId());
        assertEquals("John", response.getBody().getName());
    }
}
```

## Part 7: Practical Project Structure

A typical Spring Boot project structure looks like:

```
com.example.myapp/
├── controller/    # REST endpoints
├── service/       # Business logic
├── repository/    # Data access
├── model/         # Data models
│   ├── entity/    # JPA entities
│   └── dto/       # Data Transfer Objects
├── exception/     # Custom exceptions
├── config/        # Configuration classes
└── util/          # Utility classes
```

### Architectural Layers:

1. **Controller Layer**: Handles HTTP requests/responses
2. **Service Layer**: Contains business logic
3. **Repository Layer**: Handles data access
4. **Model Layer**: Defines data structures

## Part 8: Essential Spring Boot Annotations

- `@SpringBootApplication`: Marks the main class
- `@Component`, `@Service`, `@Repository`, `@Controller`: Define beans
- `@Autowired`: Injects dependencies (constructor injection is preferred)
- `@RequestMapping`, `@GetMapping`, `@PostMapping`: Map HTTP requests
- `@PathVariable`, `@RequestParam`: Extract data from requests
- `@RequestBody`: Convert JSON to objects
- `@ResponseBody`: Convert objects to JSON
- `@Entity`, `@Id`: JPA annotations for database mapping
- `@Value`: Inject configuration properties
- `@ConfigurationProperties`: Type-safe configuration

## Next Steps

Once you're comfortable with these basics, you can explore:

1. **Spring Security**: Authentication and authorization
2. **Spring Boot Actuator**: Production-ready features like health checks
3. **Testing**: More advanced testing techniques
4. **Profiles**: Environment-specific configuration
5. **Caching**: Improve performance with caching
6. **Messaging**: Working with message queues

## Practice Project Ideas

1. **Todo API**: Create a simple todo list API with CRUD operations
2. **User Management System**: Create an API to manage users with validation
3. **Blog API**: Create an API for blog posts and comments with relationships

Remember, the best way to learn Spring Boot is by building projects. Start small, and gradually add more features as you become comfortable with the framework!