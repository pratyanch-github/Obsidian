
# Complete Todo API Example with Spring Boot

This example demonstrates a complete Todo API with all essential Spring Boot concepts and annotations. We'll build a RESTful API that allows you to create, read, update, and delete todo items.

## Project Structure

```
com.example.todoapi/
├── TodoApiApplication.java       # Main application class
├── controller/
│   ├── TodoController.java       # REST endpoints
│   └── GlobalExceptionHandler.java  # Exception handling
├── service/
│   └── TodoService.java          # Business logic
├── repository/
│   └── TodoRepository.java       # Data access
├── model/
│   ├── Todo.java                 # JPA entity
│   └── dto/
│       ├── TodoRequest.java      # Request DTO
│       └── TodoResponse.java     # Response DTO  
├── config/
│   └── TodoAppConfig.java        # Configuration
├── exception/
│   └── TodoNotFoundException.java  # Custom exception
└── resources/
    └── application.properties    # Application configuration
```

## 1. Main Application Class

```java
package com.example.todoapi;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TodoApiApplication {
    public static void main(String[] args) {
        SpringApplication.run(TodoApiApplication.class, args);
    }
}
```

**Explanation:**
- `@SpringBootApplication` is a convenience annotation that combines:
  - `@Configuration`: Marks the class as a source of bean definitions
  - `@EnableAutoConfiguration`: Enables Spring Boot's auto-configuration
  - `@ComponentScan`: Tells Spring to scan for components in the current package and its sub-packages

When you run this class, Spring Boot starts up, scans for components, sets up the embedded web server, and makes your application available (typically at http://localhost:8080).

## 2. Model (Entity)

```java
package com.example.todoapi.model;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;
import java.time.LocalDateTime;

@Entity
@Table(name = "todos")
public class Todo {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String description;
    private boolean completed;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // Default constructor required by JPA
    public Todo() {
    }
    
    // Constructor with fields
    public Todo(String title, String description) {
        this.title = title;
        this.description = description;
        this.completed = false;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    // Getters and setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getTitle() {
        return title;
    }
    
    public void setTitle(String title) {
        this.title = title;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public boolean isCompleted() {
        return completed;
    }
    
    public void setCompleted(boolean completed) {
        this.completed = completed;
    }
    
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
    
    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
    
    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }
    
    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }
}
```

**Explanation:**
- `@Entity`: Marks this class as a JPA entity, which will be mapped to a database table
- `@Table(name = "todos")`: Specifies the table name (optional - defaults to class name)
- `@Id`: Marks the field as the primary key
- `@GeneratedValue`: Specifies that the ID should be automatically generated

This entity represents a Todo item in our database. JPA will automatically create a corresponding table in the database.

## 3. Data Transfer Objects (DTOs)

### TodoRequest.java
```java
package com.example.todoapi.model.dto;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

public class TodoRequest {
    
    @NotBlank(message = "Title is required")
    @Size(min = 3, max = 100, message = "Title must be between 3 and 100 characters")
    private String title;
    
    @Size(max = 500, message = "Description cannot exceed 500 characters")
    private String description;
    
    private boolean completed;
    
    // Getters and setters
    public String getTitle() {
        return title;
    }
    
    public void setTitle(String title) {
        this.title = title;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public boolean isCompleted() {
        return completed;
    }
    
    public void setCompleted(boolean completed) {
        this.completed = completed;
    }
}
```

### TodoResponse.java
```java
package com.example.todoapi.model.dto;

import java.time.LocalDateTime;

public class TodoResponse {
    private Long id;
    private String title;
    private String description;
    private boolean completed;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // Getters and setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getTitle() {
        return title;
    }
    
    public void setTitle(String title) {
        this.title = title;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public boolean isCompleted() {
        return completed;
    }
    
    public void setCompleted(boolean completed) {
        this.completed = completed;
    }
    
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
    
    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
    
    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }
    
    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }
}
```

**Explanation:**
- Using separate DTOs (Data Transfer Objects) for requests and responses is a best practice
- It separates the API contract from the internal data model
- `@NotBlank` and `@Size` are validation annotations that ensure input data meets requirements

## 4. Repository

```java
package com.example.todoapi.repository;

import com.example.todoapi.model.Todo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface TodoRepository extends JpaRepository<Todo, Long> {
    
    // Find todos by completion status
    List<Todo> findByCompleted(boolean completed);
    
    // Find todos containing the given text in title
    List<Todo> findByTitleContainingIgnoreCase(String titleText);
}
```

**Explanation:**
- `@Repository`: Marks the interface as a repository bean, although it's optional since Spring Data JPA automatically detects interfaces that extend JpaRepository
- `JpaRepository<Todo, Long>`: Extends the JPA repository interface, specifying the entity type (Todo) and ID type (Long)
- Spring Data JPA automatically implements CRUD operations (create, read, update, delete)
- We've added custom finder methods that Spring Data will implement automatically based on the method name

## 5. Custom Exception

```java
package com.example.todoapi.exception;

public class TodoNotFoundException extends RuntimeException {
    
    public TodoNotFoundException(Long id) {
        super("Todo not found with id: " + id);
    }
}
```

**Explanation:**
- This custom exception will be thrown when a todo item is not found
- Using specific exceptions makes error handling more precise

## 6. Service

```java
package com.example.todoapi.service;

import com.example.todoapi.exception.TodoNotFoundException;
import com.example.todoapi.model.Todo;
import com.example.todoapi.model.dto.TodoRequest;
import com.example.todoapi.model.dto.TodoResponse;
import com.example.todoapi.repository.TodoRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class TodoService {
    
    private final TodoRepository todoRepository;
    
    // Constructor injection (preferred over field injection)
    @Autowired
    public TodoService(TodoRepository todoRepository) {
        this.todoRepository = todoRepository;
    }
    
    // Get all todos
    public List<TodoResponse> getAllTodos() {
        return todoRepository.findAll().stream()
                .map(this::convertToResponse)
                .collect(Collectors.toList());
    }
    
    // Get todos by status
    public List<TodoResponse> getTodosByStatus(boolean completed) {
        return todoRepository.findByCompleted(completed).stream()
                .map(this::convertToResponse)
                .collect(Collectors.toList());
    }
    
    // Get todo by ID
    public TodoResponse getTodoById(Long id) {
        Todo todo = todoRepository.findById(id)
                .orElseThrow(() -> new TodoNotFoundException(id));
        return convertToResponse(todo);
    }
    
    // Create a new todo
    @Transactional
    public TodoResponse createTodo(TodoRequest todoRequest) {
        Todo todo = new Todo(todoRequest.getTitle(), todoRequest.getDescription());
        todo.setCompleted(todoRequest.isCompleted());
        
        Todo savedTodo = todoRepository.save(todo);
        return convertToResponse(savedTodo);
    }
    
    // Update an existing todo
    @Transactional
    public TodoResponse updateTodo(Long id, TodoRequest todoRequest) {
        Todo todo = todoRepository.findById(id)
                .orElseThrow(() -> new TodoNotFoundException(id));
        
        todo.setTitle(todoRequest.getTitle());
        todo.setDescription(todoRequest.getDescription());
        todo.setCompleted(todoRequest.isCompleted());
        todo.setUpdatedAt(LocalDateTime.now());
        
        Todo updatedTodo = todoRepository.save(todo);
        return convertToResponse(updatedTodo);
    }
    
    // Delete a todo
    @Transactional
    public void deleteTodo(Long id) {
        if (!todoRepository.existsById(id)) {
            throw new TodoNotFoundException(id);
        }
        todoRepository.deleteById(id);
    }
    
    // Helper method to convert entity to response DTO
    private TodoResponse convertToResponse(Todo todo) {
        TodoResponse response = new TodoResponse();
        response.setId(todo.getId());
        response.setTitle(todo.getTitle());
        response.setDescription(todo.getDescription());
        response.setCompleted(todo.isCompleted());
        response.setCreatedAt(todo.getCreatedAt());
        response.setUpdatedAt(todo.getUpdatedAt());
        return response;
    }
}
```

**Explanation:**
- `@Service`: Marks the class as a service bean in the service layer
- `@Autowired`: Enables dependency injection (constructor injection is used here, which is the recommended approach)
- `@Transactional`: Ensures that database operations are performed within a transaction, providing atomicity
- The service contains the business logic for handling todos, including validation and error handling
- It converts between the Entity (Todo) and DTOs (TodoRequest/TodoResponse)

## 7. Controller

```java
package com.example.todoapi.controller;

import com.example.todoapi.model.dto.TodoRequest;
import com.example.todoapi.model.dto.TodoResponse;
import com.example.todoapi.service.TodoService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/todos")
public class TodoController {
    
    private final TodoService todoService;
    
    @Autowired
    public TodoController(TodoService todoService) {
        this.todoService = todoService;
    }
    
    // Get all todos or filter by status
    @GetMapping
    public ResponseEntity<List<TodoResponse>> getTodos(
            @RequestParam(required = false) Boolean completed) {
        
        List<TodoResponse> todos;
        if (completed != null) {
            todos = todoService.getTodosByStatus(completed);
        } else {
            todos = todoService.getAllTodos();
        }
        
        return ResponseEntity.ok(todos);
    }
    
    // Get a specific todo by ID
    @GetMapping("/{id}")
    public ResponseEntity<TodoResponse> getTodoById(@PathVariable Long id) {
        TodoResponse todo = todoService.getTodoById(id);
        return ResponseEntity.ok(todo);
    }
    
    // Create a new todo
    @PostMapping
    public ResponseEntity<TodoResponse> createTodo(@Valid @RequestBody TodoRequest todoRequest) {
        TodoResponse createdTodo = todoService.createTodo(todoRequest);
        return new ResponseEntity<>(createdTodo, HttpStatus.CREATED);
    }
    
    // Update an existing todo
    @PutMapping("/{id}")
    public ResponseEntity<TodoResponse> updateTodo(
            @PathVariable Long id,
            @Valid @RequestBody TodoRequest todoRequest) {
        
        TodoResponse updatedTodo = todoService.updateTodo(id, todoRequest);
        return ResponseEntity.ok(updatedTodo);
    }
    
    // Delete a todo
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteTodo(@PathVariable Long id) {
        todoService.deleteTodo(id);
        return ResponseEntity.noContent().build();
    }
}
```

**Explanation:**
- `@RestController`: Combines `@Controller` and `@ResponseBody`, indicating this class handles REST requests and automatically serializes return values to JSON
- `@RequestMapping("/api/todos")`: Base URL path for all endpoints in this controller
- `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`: Specific HTTP method mappings
- `@PathVariable`: Extracts values from the URL path
- `@RequestParam`: Extracts query parameters from the URL
- `@RequestBody`: Converts JSON in the request body to a Java object
- `@Valid`: Triggers validation of the request object based on annotations in TodoRequest
- `ResponseEntity`: Allows control over the HTTP response status, headers, and body

## 8. Global Exception Handler

```java
package com.example.todoapi.controller;

import com.example.todoapi.exception.TodoNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // Handle custom TodoNotFoundException
    @ExceptionHandler(TodoNotFoundException.class)
    public ResponseEntity<Map<String, String>> handleTodoNotFoundException(TodoNotFoundException ex) {
        Map<String, String> error = new HashMap<>();
        error.put("error", ex.getMessage());
        
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
    
    // Handle validation errors
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationExceptions(
            MethodArgumentNotValidException ex) {
        
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
    }
    
    // Handle generic exceptions
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleGenericException(Exception ex) {
        Map<String, String> error = new HashMap<>();
        error.put("error", "An unexpected error occurred");
        error.put("message", ex.getMessage());
        
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

**Explanation:**
- `@RestControllerAdvice`: Provides centralized exception handling across all controllers
- `@ExceptionHandler`: Specifies which exception types this method handles
- Each method returns an appropriate HTTP status code and error message for different types of exceptions
- This creates a consistent error response format for your API

## 9. Configuration Class with Properties

```java
package com.example.todoapi.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

@Configuration
public class TodoAppConfig {

    @Bean
    @Profile("dev")
    public String devDatabaseInitializer() {
        return "Development database initializer";
    }
    
    @Bean
    @Profile("prod")
    public String prodDatabaseInitializer() {
        return "Production database initializer";
    }
    
    // Type-safe configuration properties
    @Bean
    @ConfigurationProperties(prefix = "todo.app")
    public TodoAppProperties todoAppProperties() {
        return new TodoAppProperties();
    }
    
    // Properties class
    public static class TodoAppProperties {
        private String name;
        private String description;
        private int maxTodos;
        
        // Getters and setters
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public String getDescription() {
            return description;
        }
        
        public void setDescription(String description) {
            this.description = description;
        }
        
        public int getMaxTodos() {
            return maxTodos;
        }
        
        public void setMaxTodos(int maxTodos) {
            this.maxTodos = maxTodos;
        }
    }
}
```

**Explanation:**
- `@Configuration`: Marks the class as a source of bean definitions
- `@Profile`: Specifies that a bean should only be created in a specific profile (e.g., "dev" or "prod")
- `@ConfigurationProperties`: Binds external configuration properties to a Java class
- This example shows how to create environment-specific beans and type-safe configuration properties

## 10. Using Value Annotation Example (continued)

```java
package com.example.todoapi.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class ConfigurationService {

    @Value("${todo.app.name:Todo Application}")
    private String appName;
    
    @Value("${server.port}")
    private int serverPort;
    
    @Value("${todo.app.enable-notifications:false}")
    private boolean notificationsEnabled;
    
    public String getAppInfo() {
        return "App: " + appName + ", Port: " + serverPort + 
               ", Notifications: " + (notificationsEnabled ? "enabled" : "disabled");
    }
    
    // Getters
    public String getAppName() {
        return appName;
    }
    
    public int getServerPort() {
        return serverPort;
    }
    
    public boolean isNotificationsEnabled() {
        return notificationsEnabled;
    }
}
```

**Explanation:**
- `@Value`: Injects property values from the application configuration
- The syntax `${property.name:default-value}` provides a default value if the property isn't found
- This is useful for simple property injection, while `@ConfigurationProperties` is better for grouping related properties

## 11. Application Properties

```properties
# src/main/resources/application.properties

# Server configuration
server.port=8080
server.servlet.context-path=/todo-api

# Database configuration
spring.datasource.url=jdbc:h2:mem:tododb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

# Enable H2 console for development
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# JPA/Hibernate properties
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Application-specific properties
todo.app.name=Todo Management Application
todo.app.description=A Spring Boot application for managing todo items
todo.app.max-todos=100
todo.app.enable-notifications=false

# Logging configuration
logging.level.com.example.todoapi=DEBUG
logging.level.org.springframework=INFO
logging.level.org.hibernate=INFO
```

**Explanation:**
- This configuration file contains properties used by Spring Boot and our application
- `server.*`: Configures the embedded web server
- `spring.datasource.*`: Configures the database connection
- `spring.jpa.*`: Configures JPA/Hibernate behavior
- `todo.app.*`: Our custom application properties
- `logging.*`: Configures logging levels

## 12. Testing the Application

### Unit Test for Service

```java
package com.example.todoapi.service;

import com.example.todoapi.exception.TodoNotFoundException;
import com.example.todoapi.model.Todo;
import com.example.todoapi.model.dto.TodoRequest;
import com.example.todoapi.model.dto.TodoResponse;
import com.example.todoapi.repository.TodoRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class TodoServiceTest {

    @Mock
    private TodoRepository todoRepository;

    @InjectMocks
    private TodoService todoService;

    private Todo todo1;
    private Todo todo2;
    private TodoRequest todoRequest;

    @BeforeEach
    void setUp() {
        // Create test data
        todo1 = new Todo("Test Todo 1", "Description 1");
        todo1.setId(1L);
        todo1.setCompleted(false);
        todo1.setCreatedAt(LocalDateTime.now());
        todo1.setUpdatedAt(LocalDateTime.now());

        todo2 = new Todo("Test Todo 2", "Description 2");
        todo2.setId(2L);
        todo2.setCompleted(true);
        todo2.setCreatedAt(LocalDateTime.now());
        todo2.setUpdatedAt(LocalDateTime.now());

        todoRequest = new TodoRequest();
        todoRequest.setTitle("New Todo");
        todoRequest.setDescription("New Description");
        todoRequest.setCompleted(false);
    }

    @Test
    void getAllTodos_ShouldReturnAllTodos() {
        // Arrange
        when(todoRepository.findAll()).thenReturn(Arrays.asList(todo1, todo2));

        // Act
        List<TodoResponse> result = todoService.getAllTodos();

        // Assert
        assertEquals(2, result.size());
        assertEquals(todo1.getTitle(), result.get(0).getTitle());
        assertEquals(todo2.getTitle(), result.get(1).getTitle());
        verify(todoRepository, times(1)).findAll();
    }

    @Test
    void getTodoById_WhenTodoExists_ShouldReturnTodo() {
        // Arrange
        when(todoRepository.findById(1L)).thenReturn(Optional.of(todo1));

        // Act
        TodoResponse result = todoService.getTodoById(1L);

        // Assert
        assertNotNull(result);
        assertEquals(todo1.getId(), result.getId());
        assertEquals(todo1.getTitle(), result.getTitle());
        verify(todoRepository, times(1)).findById(1L);
    }

    @Test
    void getTodoById_WhenTodoDoesNotExist_ShouldThrowException() {
        // Arrange
        when(todoRepository.findById(999L)).thenReturn(Optional.empty());

        // Act & Assert
        assertThrows(TodoNotFoundException.class, () -> {
            todoService.getTodoById(999L);
        });
        verify(todoRepository, times(1)).findById(999L);
    }

    @Test
    void createTodo_ShouldSaveTodo() {
        // Arrange
        Todo savedTodo = new Todo(todoRequest.getTitle(), todoRequest.getDescription());
        savedTodo.setId(3L);
        savedTodo.setCompleted(todoRequest.isCompleted());
        savedTodo.setCreatedAt(LocalDateTime.now());
        savedTodo.setUpdatedAt(LocalDateTime.now());

        when(todoRepository.save(any(Todo.class))).thenReturn(savedTodo);

        // Act
        TodoResponse result = todoService.createTodo(todoRequest);

        // Assert
        assertNotNull(result);
        assertEquals(savedTodo.getId(), result.getId());
        assertEquals(todoRequest.getTitle(), result.getTitle());
        assertEquals(todoRequest.getDescription(), result.getDescription());
        verify(todoRepository, times(1)).save(any(Todo.class));
    }
}
```

**Explanation:**
- `@ExtendWith(MockitoExtension.class)`: Enables Mockito for this test class
- `@Mock`: Creates a mock instance of the specified class
- `@InjectMocks`: Creates an instance of the class and injects mocks into it
- Each test method follows the Arrange-Act-Assert pattern
- We use Mockito to define behavior for the repository mock
- This allows us to test the service layer in isolation

### Integration Test for Controller

```java
package com.example.todoapi.controller;

import com.example.todoapi.model.dto.TodoRequest;
import com.example.todoapi.model.Todo;
import com.example.todoapi.repository.TodoRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
public class TodoControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private TodoRepository todoRepository;

    @BeforeEach
    void setUp() {
        // Clear the database before each test
        todoRepository.deleteAll();

        // Add test data
        Todo todo1 = new Todo("Integration Test Todo", "Test Description");
        todoRepository.save(todo1);
    }

    @Test
    void getAllTodos_ShouldReturnTodos() throws Exception {
        mockMvc.perform(get("/api/todos"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$", hasSize(greaterThanOrEqualTo(1))))
                .andExpect(jsonPath("$[0].title", containsString("Integration Test Todo")));
    }

    @Test
    void createTodo_WithValidData_ShouldCreateTodo() throws Exception {
        TodoRequest todoRequest = new TodoRequest();
        todoRequest.setTitle("New Todo from Test");
        todoRequest.setDescription("Description from integration test");

        mockMvc.perform(post("/api/todos")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(todoRequest)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.title", is("New Todo from Test")))
                .andExpect(jsonPath("$.id", notNullValue()));
    }

    @Test
    void createTodo_WithInvalidData_ShouldReturnBadRequest() throws Exception {
        TodoRequest todoRequest = new TodoRequest();
        todoRequest.setTitle(""); // Empty title should fail validation
        todoRequest.setDescription("Description");

        mockMvc.perform(post("/api/todos")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(todoRequest)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.title", notNullValue())); // Should have error message for title
    }

    @Test
    void getTodoById_WithExistingId_ShouldReturnTodo() throws Exception {
        // First, get all todos to find an ID
        String responseString = mockMvc.perform(get("/api/todos"))
                .andExpect(status().isOk())
                .andReturn().getResponse().getContentAsString();
        
        int idIndex = responseString.indexOf("\"id\":");
        String idSubstring = responseString.substring(idIndex + 5);
        Long id = Long.parseLong(idSubstring.substring(0, idSubstring.indexOf(",")));

        // Now test getting that specific todo
        mockMvc.perform(get("/api/todos/" + id))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id", is(id.intValue())))
                .andExpect(jsonPath("$.title", containsString("Integration Test Todo")));
    }
}
```

**Explanation:**
- `@SpringBootTest`: Loads the full application context for testing
- `@AutoConfigureMockMvc`: Sets up MockMvc for testing web endpoints
- `MockMvc`: Used to perform HTTP requests without starting a real server
- We use the actual database (in this case, in-memory H2) for integration testing
- The tests verify that the whole stack (controller, service, repository) works together

## 13. Running the Application

To run the application:

1. Ensure you have Java 8+ and Maven installed
2. Build the application: `mvn clean package`
3. Run the application: `java -jar target/todo-api-0.0.1-SNAPSHOT.jar`
4. Or use Spring Boot Maven plugin: `mvn spring-boot:run`

Once started, you can access:
- The API at: http://localhost:8080/todo-api/api/todos
- H2 console at: http://localhost:8080/todo-api/h2-console (for development)

## 14. API Endpoints Summary

| HTTP Method | URL | Description |
|-------------|-----|-------------|
| GET | /api/todos | Get all todos or filter by completion status |
| GET | /api/todos/{id} | Get a specific todo by ID |
| POST | /api/todos | Create a new todo |
| PUT | /api/todos/{id} | Update an existing todo |
| DELETE | /api/todos/{id} | Delete a todo |

## 15. Key Spring Boot Annotations Used

| Annotation | Description |
|------------|-------------|
| `@SpringBootApplication` | Marks the main class, combines @Configuration, @EnableAutoConfiguration, and @ComponentScan |
| `@Entity` | Marks a class as a JPA entity mapped to a database table |
| `@Id` | Identifies the primary key of an entity |
| `@Service` | Marks a class as a service component in the business layer |
| `@Repository` | Marks an interface as a repository component in the data access layer |
| `@RestController` | Marks a class as a controller that handles REST requests |
| `@RequestMapping` | Maps HTTP requests to handler methods |
| `@GetMapping`, `@PostMapping`, etc. | Specialized versions of @RequestMapping for specific HTTP methods |
| `@RequestBody` | Binds the HTTP request body to a method parameter |
| `@PathVariable` | Extracts values from the URI path |
| `@RequestParam` | Extracts query parameters from the request |
| `@Autowired` | Injects dependencies |
| `@Transactional` | Defines transaction boundaries |
| `@Value` | Injects property values |
| `@ConfigurationProperties` | Binds external configuration to structured objects |
| `@Valid` | Triggers validation of annotated objects |
| `@ExceptionHandler` | Handles exceptions thrown from controller methods |
| `@RestControllerAdvice` | Centralizes exception handling across controllers |

## Summary

This example demonstrates a complete Todo API built with Spring Boot, showcasing:

1. **Layered Architecture**:
   - Controllers handle HTTP requests
   - Services contain business logic
   - Repositories manage data access
   - Clear separation of concerns

2. **Spring Boot Features**:
   - Auto-configuration simplifies setup
   - Dependency injection promotes loose coupling
   - Annotations reduce boilerplate code
   - Built-in validation and error handling

3. **Key Design Patterns**:
   - DTO (Data Transfer Object) pattern for API contracts
   - Repository pattern for data access
   - Dependency Injection for loose coupling
   - Exception handling for robust error responses

By understanding this example, you've gained insight into how Spring Boot applications are structured and how the various annotations and components work together to create a functioning API. This knowledge forms a solid foundation for building your own Spring Boot applications.